"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForAngular = exports.getAllHarnesses = exports.getHarness = exports.createHarnessEnvironment = void 0;
const tslib_1 = require("tslib");
const WebdriverIOHarnessEnvironment_1 = require("./WebdriverIOHarnessEnvironment");
/**
 * Returns a base harness environment instance.
 * @return An HarnessLoader instance for the current HTML document, rooted at the document's root element
 */
const createHarnessEnvironment = (documentRoot) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return WebdriverIOHarnessEnvironment_1.WebdriverIOHarnessEnvironment.loader(documentRoot || (yield $('body')));
});
exports.createHarnessEnvironment = createHarnessEnvironment;
/**
 * Searches for an instance of the component corresponding to the given harness type under the
 * `HarnessLoader`'s root element, and returns a `ComponentHarness` for that instance. If multiple
 * matching components are found, a harness for the first one is returned. If no matching
 * component is found, an error is thrown.
 * @param query A query for a harness to create
 * @return An instance of the given harness type
 * @throws If a matching component instance can't be found.
 */
const getHarness = (query) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return (yield exports.createHarnessEnvironment()).getHarness(query);
});
exports.getHarness = getHarness;
/**
 * Searches for all instances of the component corresponding to the given harness type under the
 * `HarnessLoader`'s root element, and returns a list `ComponentHarness` for each instance.
 * @param query A query for a harness to create
 * @return A list instances of the given harness type.
 */
const getAllHarnesses = (query) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    return (yield exports.createHarnessEnvironment()).getAllHarnesses(query);
});
exports.getAllHarnesses = getAllHarnesses;
/**
 * Returns a promise that resolves when the application is "stable".
 * The promise might be rejected due to timeouts, or async tasks in the client
 * app that never finish (timers, etc).
 */
const waitForAngular = () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    yield browser.waitUntil(() => browser.executeScript(`
        return Array.isArray(window.frameworkStabilizers)
    `, []));
    yield browser.executeAsyncScript(`
        const done = arguments[0];
        const promises = window.frameworkStabilizers.map(stabilizer => {
            // Stabilizer will invoke the resolve function with a
            // boolean to indicate whether any work is done.
            return new Promise(resolve => stabilizer(resolve));
        });
        Promise.all(promises).then(done);
    `, []);
});
exports.waitForAngular = waitForAngular;
