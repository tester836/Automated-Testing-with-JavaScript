"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebdriverIOTestElement = void 0;
const tslib_1 = require("tslib");
const testing_1 = require("@angular/cdk/testing");
const logger_1 = tslib_1.__importDefault(require("@wdio/logger"));
const safe_1 = require("@colors/colors/safe");
var Button;
(function (Button) {
    Button["LEFT"] = "left";
    Button["MIDDLE"] = "middle";
    Button["RIGHT"] = "right";
})(Button || (Button = {}));
/** Registers the element logger. */
const log = logger_1.default('wdio-harness');
/** Maps the `TestKey` constants to WebdriverIO's `Key` constants. */
const keyMap = {
    [testing_1.TestKey.BACKSPACE]: 'Backspace',
    [testing_1.TestKey.TAB]: 'Tab',
    [testing_1.TestKey.ENTER]: 'Enter',
    [testing_1.TestKey.SHIFT]: 'Shift',
    [testing_1.TestKey.CONTROL]: 'Control',
    [testing_1.TestKey.ALT]: 'Alt',
    [testing_1.TestKey.ESCAPE]: 'Escape',
    [testing_1.TestKey.PAGE_UP]: 'PageUp',
    [testing_1.TestKey.PAGE_DOWN]: 'PageDown',
    [testing_1.TestKey.END]: 'End',
    [testing_1.TestKey.HOME]: 'Home',
    [testing_1.TestKey.LEFT_ARROW]: 'ArrowLeft',
    [testing_1.TestKey.UP_ARROW]: 'ArrowUp',
    [testing_1.TestKey.RIGHT_ARROW]: 'ArrowRight',
    [testing_1.TestKey.DOWN_ARROW]: 'ArrowDown',
    [testing_1.TestKey.INSERT]: 'Insert',
    [testing_1.TestKey.DELETE]: 'Delete',
    [testing_1.TestKey.F1]: 'F1',
    [testing_1.TestKey.F2]: 'F2',
    [testing_1.TestKey.F3]: 'F3',
    [testing_1.TestKey.F4]: 'F4',
    [testing_1.TestKey.F5]: 'F5',
    [testing_1.TestKey.F6]: 'F6',
    [testing_1.TestKey.F7]: 'F7',
    [testing_1.TestKey.F8]: 'F8',
    [testing_1.TestKey.F9]: 'F9',
    [testing_1.TestKey.F10]: 'F10',
    [testing_1.TestKey.F11]: 'F11',
    [testing_1.TestKey.F12]: 'F12',
    [testing_1.TestKey.META]: 'Meta'
};
/** Converts a `ModifierKeys` object to a list of WebdriverIO `Key`s. */
const toWebdriverIOModifierKeys = (modifiers) => {
    const result = [];
    if (modifiers.control) {
        result.push(keyMap[testing_1.TestKey.CONTROL]);
    }
    if (modifiers.alt) {
        result.push(keyMap[testing_1.TestKey.ALT]);
    }
    if (modifiers.shift) {
        result.push(keyMap[testing_1.TestKey.SHIFT]);
    }
    if (modifiers.meta) {
        result.push(keyMap[testing_1.TestKey.META]);
    }
    return result;
};
/**
 * A `TestElement` implementation for WebdriverIO.
 */
class WebdriverIOTestElement {
    constructor(element) {
        this.element = element;
    }
    /** Blur the element. */
    blur() {
        this.logAction('BLUR');
        return browser.executeScript('arguments[0].blur()', [this.element]);
    }
    /** Clear the element's input (for input and textarea elements only). */
    clear() {
        this.logAction('CLEAR');
        return this.element.clearValue();
    }
    click(...args) {
        this.logAction('CLICK');
        return this.dispatchClickEventSequence(args, Button.LEFT);
    }
    rightClick(...args) {
        this.logAction('RIGHT_CLICK');
        return this.dispatchClickEventSequence(args, Button.RIGHT);
    }
    /** Focus the element. */
    focus() {
        this.logAction('FOCUS');
        return browser.executeScript('arguments[0].focus()', [this.element]);
    }
    /** Get the computed value of the given CSS property for the element. */
    getCssValue(property) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logAction('GET_CSS_VALUE');
            return (yield this.element.getCSSProperty(property)).value || '';
        });
    }
    /** Hovers the mouse over the element. */
    hover() {
        this.logAction('HOVER');
        return this.element.moveTo();
    }
    /** Moves the mouse away from the element. */
    mouseAway() {
        this.logAction('MOUSE_AWAY');
        return this.element.moveTo({ xOffset: -1, yOffset: -1 });
    }
    sendKeys(...modifiersAndKeys) {
        let modifiers;
        let rest;
        const first = modifiersAndKeys[0];
        if (typeof first !== 'string' && typeof first !== 'number') {
            modifiers = first;
            rest = modifiersAndKeys.slice(1);
        }
        else {
            modifiers = {};
            rest = modifiersAndKeys;
        }
        const KeyNULL = String.fromCharCode(57344);
        const modifierKeys = toWebdriverIOModifierKeys(modifiers);
        const keys = rest
            .map(k => (typeof k === 'string' ? k.split('') : [keyMap[k]]))
            .reduce((arr, k) => arr.concat(k), [])
            .reduce((arr, k) => {
            if (modifierKeys.length > 0) {
                return arr.concat(...modifierKeys, k, KeyNULL);
            }
            return arr.concat(k);
        }, []);
        this.logAction('SEND_KEYS', `[${keys.join(', ')}]`);
        return this.element.setValue(keys);
    }
    /** Gets the text from the element. */
    text(options) {
        this.logAction('TEXT', `{ exclude: ${options === null || options === void 0 ? void 0 : options.exclude} }`);
        if (options === null || options === void 0 ? void 0 : options.exclude) {
            return browser.executeScript(`
                const clone = arguments[0].cloneNode(true) as Element;
                const exclusions = clone.querySelectorAll(arguments[1]);
                for (let i = 0; i < exclusions.length; i++) {
                    exclusions[i].remove();
                }
                return (clone.textContent || '').trim();
            `, [this.element, options.exclude]);
        }
        // We don't go through WebdriverIO's `getText`, because it excludes text from hidden elements.
        return browser.executeScript(`return (arguments[0].textContent || '').trim()`, [this.element]);
    }
    /** Gets the value for the given attribute from the element. */
    getAttribute(name) {
        this.logAction('GET_ATTRIBUTE', name);
        return this.element.getAttribute(name);
    }
    /** Checks whether the element has the given class. */
    hasClass(name) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logAction('HAS_CLASS', name);
            const classes = (yield this.getAttribute('class')) || '';
            return new Set(classes.split(/\s+/).filter(c => c)).has(name);
        });
    }
    /** Gets the dimensions of the element. */
    getDimensions() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logAction('GET_DIMENSIONS');
            const { width, height } = yield this.element.getSize();
            const { x: left, y: top } = yield this.element.getLocation();
            return { width, height, left, top };
        });
    }
    /** Gets the value of a property of an element. */
    getProperty(name) {
        this.logAction('GET_PROPERTY', name);
        return this.element.getProperty(name);
    }
    /** Checks whether this element matches the given selector. */
    matchesSelector(selector) {
        this.logAction('MATCHES_SELECTOR', selector);
        return browser.executeScript(`
            return (Element.prototype.matches || Element.prototype.msMatchesSelector).call(arguments[0], arguments[1])
        `, [this.element, selector]);
    }
    /** Checks whether the element is focused. */
    isFocused() {
        this.logAction('IS_FOCUSED');
        return this.element.isFocused();
    }
    /** Sets the value of a property of an input. */
    setInputValue(value) {
        this.logAction('SET_INPUT_VALUE', value);
        return this.element.setValue(value);
    }
    /** Selects the options at the specified indexes inside of a native `select` element. */
    selectOptions(...optionIndexes) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logAction('SELECT_OPTIONS', `[${optionIndexes.join(', ')}]`);
            const options = yield this.element.$$('option');
            const indexes = new Set(optionIndexes); // Convert to a set to remove duplicates.
            if (options.length && indexes.size) {
                // Reset the value so all the selected states are cleared. We can
                // reuse the input-specific method since the logic is the same.
                yield this.setInputValue('');
                for (let i = 0; i < options.length; i++) {
                    if (indexes.has(i)) {
                        // We have to hold the control key while clicking on options so that multiple can be
                        // selected in multi-selection mode. The key doesn't do anything for single selection.
                        yield this.keyDown(keyMap[testing_1.TestKey.CONTROL]);
                        yield options[i].click();
                        yield this.keyUp(keyMap[testing_1.TestKey.CONTROL]);
                    }
                }
            }
        });
    }
    /** Dispatches an event with a particular name. */
    dispatchEvent(name, data) {
        this.logAction('DISPATCH_EVENT', name);
        return browser.executeScript(`
            const event = document.createEvent('Event');
            event.initEvent(arguments[0]);
            if (arguments[2]) {
                Object.assign(event, arguments[2]);
            }
            arguments[1]['dispatchEvent'](event);
        `, [name, this.element, data]);
    }
    // --- HELPER(s) ---
    /** Dispatches all the events that are part of a click event sequence. */
    dispatchClickEventSequence(args, button) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let modifiers = {};
            if (args.length && typeof args[args.length - 1] === 'object') {
                modifiers = args.pop();
            }
            const modifierKeys = toWebdriverIOModifierKeys(modifiers);
            // Omitting the offset argument to mouseMove results in clicking the center.
            // This is the default behavior we want, so we use an empty array of offsetArgs if
            // no args remain after popping the modifiers from the args passed to this function.
            const offsetArgs = (args.length === 2 ? { xOffset: Number(args[0]), yOffset: Number(args[1]) } : undefined);
            yield this.element.moveTo(offsetArgs);
            for (const modifierKey of modifierKeys) {
                this.keyDown(modifierKey);
            }
            yield this.element.click({ button });
            for (const modifierKey of modifierKeys) {
                this.keyUp(modifierKey);
            }
        });
    }
    /** Performs a key-down action. */
    keyDown(value) {
        this.logAction('KEY_DOWN:', value);
        return browser.performActions([{
                id: 'keyboard',
                type: 'key',
                actions: [{ type: 'keyDown', value }],
            }]);
    }
    /** Performs a key-up action. */
    keyUp(value) {
        this.logAction('KEY_UP:', value);
        return browser.performActions([{
                id: 'keyboard',
                type: 'key',
                actions: [{ type: 'keyUp', value }],
            }]);
    }
    /** Writes info to the console outputs. */
    logAction(action, args) {
        log.info(`${safe_1.magenta(action)} ${safe_1.green(this.element.selector.toString())} ${args ? args : ''}`);
    }
}
exports.WebdriverIOTestElement = WebdriverIOTestElement;
